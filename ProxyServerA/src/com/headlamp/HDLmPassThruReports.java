package com.headlamp;
import static com.headlamp.HDLmAssert.HDLmAssertAction;

import java.time.Instant;
import java.util.ArrayList;
import java.util.Set;
import java.util.TreeMap;

import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.mutable.MutableInt;

import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
/**
 * HDLmPassThruReports short summary.
 *
 * HDLmPassThruReports description.
 *
 * @version 1.0
 * @author Peter
 */
/* This is not a purely static class and instances of this class
   can definitely be created. In practice, one instance of this 
   class will be created for each set of reports. A report is created
   each time the verification tests are run against one company. */
/* An instance of this class is created to store all of the reports 
   generated by running the verification tests. Each company has one 
   set of reports. */  
/* An instance of this class is created for each set of reports. 
   The name of this class notwithstanding, this class does not do 
   any pass-through processing. The name was picked for consistency
   with other related classes. */ 
public class HDLmPassThruReports extends HDLmMod {
	/* This is the default constructor for this class. It doesn't do
	   anything. All fields of this class will be set to the default 
	   values specified. */
  protected HDLmPassThruReports() { 
		/* Invoke the default constructor for the parent class. This is 
	     required by the Java language. */ 
	  super();
  	/* Declare and define a few variables */
	  Instant  currentTimestampInstant = Instant.now(); 
  	/* Set a few fields in the new reports instance */
  	created = currentTimestampInstant;
  	lastModified = currentTimestampInstant;
  	associatedNodeType = HDLmTreeTypes.REPORTS;
  	countReports = 0;
  	reports = new TreeMap<String, HDLmPassThruReport>();
  	if (reports == null)
  		HDLmAssertAction(false, "New TreeMap<> not created for reports");
  }
	/* This is one of the constructors for the reports definition class.
	   It must be passed a JSON element that contains all of the details
	   of the reports definition. */
	protected HDLmPassThruReports(JsonElement jsonElement) {
		/* Invoke the default constructor for the parent class. This is 
		   required by the Java language. */ 
		super();
		/* Check if a null JSON element reference was passed to this routine */
		if (jsonElement == null) {
			String  errorText = "JSON element used to build reports definition details is null";
			throw new NullPointerException(errorText);
		}
		/* Declare and define a few variables */
		Integer   curInteger;
		/* Show that we are handling a pass-through definition */
		HDLmEditorTypes  editorType = HDLmEditorTypes.PASS;
		/* Create the reports entry collection that will be needed later */
   	reports = new TreeMap<String, HDLmPassThruReport>();
  	if (reports == null)
  		HDLmAssertAction(false, "New TreeMap<> not created for reports");
		/* Set the error count to zero. The error count is incremented each time an
			 error is detected. If the final error count (for the current definition) is
			 greater than zero, the current definition object is disabled (the enabled
			 field is set false). Note that a reference is used below so that the error
			 count can be updated by the routines called using error count.*/
	  MutableInt   errorCounter = new MutableInt(0);
		/* Build an array list for error message strings. Each error
	     message is stored in this array list. */
   	ArrayList<String>   errorMessages = new ArrayList<String>();
	  if (errorMessages == null) {
		  String  errorText = "Error message ArrayList allocation in HDLmPassThruReports constructor is null";
		  throw new NullPointerException(errorText);
	  }	
	  
	  /* Get the list of keywords and values in the JSON object */
	  if (jsonElement.isJsonNull()) {
	 	  HDLmAssertAction(false, "JSON element used to build reports definition is JSON null");
	  }
	  JsonObject jsonObject = jsonElement.getAsJsonObject();
	  Set<String> jsonKeys = jsonObject.keySet();
	  /* Get the standard class instance variables */
	  HDLmPassThruResponse  response = HDLmPassThruResponse.getStandardFields(jsonElement, 
		  	                                                                    HDLmTreeTypes.REPORTS,
		  	                                                                    HDLmGetComments.GETCOMMENTSNO,
																																			      HDLmGetCreated.GETCREATEDYES,
																																			      HDLmGetLastModified.GETLASTMODIFIEDYES,
																																			      HDLmGetPassThruStatus.GETSTATUSNO,
																																			      HDLmOptEnabled.OPTENABLEDYES,
																																		        HDLmOptExtra.OPTEXTRAYES,
																																		        HDLmGetUpdated.GETUPDATEDYES);
	  if (response == null) {
	  	String  errorText = "Null response from build standard fields routine";
		  HDLmAssertAction(false, errorText);
	  }
	  /* Update the error count with the response value */
	  errorCounter.add(response.getErrorCount()); 
	  /* Extract the fields from the build standard fields response */
	  setName(response.getName());
		/* Get and check the current type */
	  associatedNodeType = response.getAssociatedNodeType();
		/* Get a few fields from the JSON object */
		Boolean enabledBoolean = response.getEnabled();
		if (enabledBoolean != null)
		  setEnabled(enabledBoolean);
		/* Try to get the comments value from the JSON element. Note that
		   the call below will never report an error unless the comments
		   field is actually missing from the JSON. This does not appear
		   to be true in any actual case. Note that the comments are
		   optional. Skip this code is we don't have any comments. */
		String  commentsInfo = response.getComments();		 
		if (commentsInfo != null && !StringUtils.isWhitespace(commentsInfo)) {
		  setComments(commentsInfo);
		}	 
		/* Try to get the extra information value from the JSON element.
		   Note that the call below will never report an error unless the
		   extra information field is actually missing from the JSON.
		   This does not appear to be true in any actual case. */
		String extraInfo = response.getExtra();  
		if (extraInfo != null && !StringUtils.isWhitespace(extraInfo)) {
			setExtra(extraInfo);
		}
		/* Get the created date and time and use them to set an instance field */
		created = response.getCreated();
		/* Get the last modified date and time and use them to set an instance field */
		lastModified = response.getLastModified();
		/* Get an integer value and use it to set an instance field */ 
	  curInteger = HDLmMod.modFieldInteger(editorType, 
	  		                                 errorCounter,
	  		                                 errorMessages, 
	                                       jsonObject, 
	                                       jsonKeys, 
		                                     "countReports", 
		                                     HDLmReportErrors.REPORTERRORS);
	  countReports = curInteger;
	  /* We don't really want to use the count of reports we obtained from
       the JSON. We really need to use the reports count we get by adding
       each report to the set of reports. */ 
    countReports = 0; 
		/* Mark the current report definition object as disabled
		   if the error count was greater than zero. This is actually
		   done by setting the enabled field to false. */
		if (errorCounter.intValue() > 0) {
			setEnabled((Boolean) false);
	  }
	}
	/* Getters and setters are provided for the values that 
	   need to be obtained and/or set */ 
	private HDLmTreeTypes                 associatedNodeType = null;
  private Integer                       countReports = 0;
  TreeMap<String, HDLmPassThruReport>   reports = null;
  /* This method adds a report to the existing set of reports 
	   (zero, one, or more) */
	protected void          addReport(HDLmPassThruReport newReport, HDLmStartupMode startupMode) {
		/* Check if the pass-through report reference passed by the caller is null */
		if (newReport == null) {
		  String  errorText = "New report reference passed to addReport is null";
		  throw new NullPointerException(errorText);
	  }
		/* Check if the startup mode value passed by the caller is null */
		if (startupMode == null) {
			String   errorText = "Startup mode value passed to addReport is null";
			throw new NullPointerException(errorText);		
		}
		/* Check if the startup mode passed by the caller is invalid */
		if (startupMode == HDLmStartupMode.NONE) {
		  HDLmAssertAction(false, "Startup mode value passed to addReport is invalid");
		}
		/* Add the new report to the set of reports */
		String  newReportName = newReport.getName();
		countReports++;
		reports.put(newReportName, newReport);
	  /* Reset the last modified date and time */
		if (startupMode == HDLmStartupMode.STARTUPMODENO)
	    lastModified = Instant.now();
	}  
	/* This routine builds a tree node for a reports (set of reports) 
	   and returns the final reports (set of reports) tree node to the
	   caller. The reports (set of reports)  reference is used to set
	   the details of the new tree node. */ 
	protected static HDLmTree  buildTree(ArrayList<String> oldNodePath, 
			                                 HDLmPassThruReports newValue) {
		/* Check if the old node path reference passed by the caller is null */
		if (oldNodePath == null) {
		  String  errorText = "Node path reference passed to buildTree is null";
		  throw new NullPointerException(errorText);
	  }
		/* Check if the pass-through reports (set of reports) reference passed by the caller is null */
		if (newValue == null) {
		  String  errorText = "Reports reference passed to buildTree is null";
		  throw new NullPointerException(errorText);
	  }
		/* Get some information about the current reports (set of reports) */
		HDLmTreeTypes  nodeType = HDLmTreeTypes.REPORTS;
		String    nodeName = newValue.getName();
		String    nodeTypeStringLowerCase = nodeType.toString().toLowerCase();
		String    nodeTooltip = HDLmTree.getTooltipString(nodeTypeStringLowerCase);
		ArrayList<String>  nodePath = new ArrayList<String>(oldNodePath);
		nodePath.add(nodeName);
		/* Build a new tree node with the correct information */
		HDLmTree  reportsTree = new HDLmTree(nodeType,
																	       nodeTooltip,
																	       nodePath);
		if (reportsTree == null) {
			String  errorText = "New reports tree node was not created";
			HDLmAssertAction(false, errorText);
		}
		/* Use the reports instance as the details of the new tree node */
		reportsTree.setDetails(newValue);		
		return reportsTree;	
	}
  /* Get the value of the associated node type field and return it to the caller */
  protected HDLmTreeTypes  getAssociatedNodeTType() {
  	return associatedNodeType;
  }
	/* This routine returns a reference to the created instant */  
  protected Instant      getCreated() {
	  return created;		
  } 
	/* This method returns the highest report name to the caller.
     Of course, no reports may actually exist. In that case, a
     null value is returned to the caller. */
  protected String       getHighReportName() {
  	/* Check if report tree map has actually been created. If not,
  	   just return a null value to the caller. */
  	if (reports == null)
  	  return null;
  	/* Return the highest key from the reports tree map. Of course,
  	   if the reports tree map is empty, we will return a null value. */
  	if (reports.isEmpty())
  		return null;
  	return reports.lastKey();
  } 
	/* This routine returns a reference to the last modified instant */  
  protected Instant      getLastModified() {
	  return lastModified;		
  } 
  /* This routine returns the current number of reports for the 
     current company. No other changes are made. */
  protected int          getReportsCount() {
    return countReports;
  } 
  /* This routine sets the associated node type of this class
     instance to a null value */  
	protected final void   setAssociatedNodeTypeNull() { 
	  lastModified = Instant.now();
	  associatedNodeType = null;
	}
	/* This routine sets the reference to the created instant */  
  protected final void   setCreated(final Instant newCreated) {
	  /* Check if the created reference passed by the caller is null */
	  if (newCreated == null) {
	    String  errorText = "Created reference passed to setCreated is null";
	    throw new NullPointerException(errorText);
	  }
	  created = newCreated;		
  } 
	/* This routine sets the reference to the last modified instant */  
  protected final void   setLastModified(final Instant newLastModified) {
	  /* Check if the last modified reference passed by the caller is null */
	  if (newLastModified == null) {
	    String  errorText = "Last modified reference passed to setLastModified is null";
	    throw new NullPointerException(errorText);
	  }
	  lastModified = newLastModified;		
  } 
	/* This routine sets the reports count to a value passed by the caller */  
  protected final void   setReportsCount(final int newReportsCount) {
	  /* Check if the reports count passed by the caller is valid */
	  if (newReportsCount < 0) {
	    String  errorText = "Reports count passed to setReportsCount is invalid";
	    throw new IllegalArgumentException(errorText);  	
	  }
	  lastModified = Instant.now();
	  countReports = newReportsCount;		
  }
  /* This routine sets the reports reference of this class
     instance to a null value */  
	protected final void   setReportsNull() { 
	  lastModified = Instant.now();
	  reports = null;
	}
}	